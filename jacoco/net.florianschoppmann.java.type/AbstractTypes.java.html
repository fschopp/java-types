<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractTypes.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Types</a> &gt; <a href="index.source.html" class="el_package">net.florianschoppmann.java.type</a> &gt; <span class="el_source">AbstractTypes.java</span></div><h1>AbstractTypes.java</h1><pre class="source lang-java linenums">package net.florianschoppmann.java.type;

import javax.annotation.Nullable;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.lang.model.type.ArrayType;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.NoType;
import javax.lang.model.type.NullType;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.type.TypeVariable;
import javax.lang.model.type.WildcardType;
import javax.lang.model.util.Types;
import java.io.Serializable;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/**
 * Abstract skeletal implementation of {@link Types}.
 *
 * &lt;p&gt;This class provides a skeletal implementation of the {@link Types} interface. Specifically, it implements all
 * methods pertaining to §4.10 (subtyping) in the Java Language Specification (JLS). Concrete subclasses are expected to
 * implement the abstract methods in this class, which are responsible for creating appropriate type-mirror instances.
 * This class does not place any additional constraints on the concrete {@link TypeMirror} and {@link Element}
 * implementations, so mutability and thread-safety are implementation-defined. However, this class crucially relies on
 * the {@code equals} method being well-defined. That is, {@link Element} objects that have equal names and equal
 * enclosing elements must compare equal. Likewise, {@link TypeMirror} objects that contain equal values must compare
 * equal. In particular, multiple instances created by one of the {@code get}-methods must compare equal when the given
 * arguments compare equal.
 *
 * &lt;p&gt;Besides subtype-related methods, this class also provides method
 * {@link #resolveActualTypeArguments(TypeElement, TypeMirror)} for resolving formal type parameters to actual type
 * arguments. For instance, given type {@code List&lt;String&gt;}, this method determines the actual type argument for the
 * formal type parameter of {@code Collection&lt;E&gt;} (that is, {@code String} in this simple example).
 *
 * &lt;p&gt;Unless explicitly stated otherwise, all methods in this class expect non-null arguments. Passing null where not
 * expected will cause a {@link NullPointerException} to be thrown. Implementations typically place additional
 * restrictions on method arguments not captured by the types of the formal parameters (which stem from
 * {@link javax.lang.model} and its subpackages). While the details are implementation-defined, typically this means
 * that arguments must have been crated by the same implementation, or otherwise an {@link IllegalArgumentException}
 * will be thrown. Implementations must override {@link #requireValidType(TypeMirror)} and
 * {@link #requireValidElement(Element)}, as these methods are expected to perform any necessary validation.
 */
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">public abstract class AbstractTypes implements Types {</span>
<span class="fc" id="L59">    private static final List&lt;TypeKind&gt; REFERENCE_TYPES = Collections.unmodifiableList(Arrays.asList(</span>
        TypeKind.ARRAY, TypeKind.DECLARED, TypeKind.NULL, TypeKind.TYPEVAR
    ));
    private static final int DEFAULT_STRING_BUILDER_SIZE = 256;

<span class="fc" id="L64">    private final SubstitutionVisitor substitutionVisitor = new SubstitutionVisitor();</span>
<span class="fc" id="L65">    private final ErasureVisitor erasureVisitor = new ErasureVisitor();</span>
<span class="fc" id="L66">    private final ToStringVisitor toStringVisitor = new ToStringVisitor();</span>
<span class="fc" id="L67">    private final SubtypeVisitor subtypeVisitor = new SubtypeVisitor();</span>
<span class="fc" id="L68">    private final DeclaredTypeSubtypeVisitor declaredTypeSubtypeVisitor = new DeclaredTypeSubtypeVisitor();</span>

    /**
     * Verifies that the given {@link Element} is valid for use with this class.
     *
     * &lt;p&gt;The meaning of valid is implementation-defined, but typically a valid {@link Element} must have been created
     * by the implementation that belongs to the current {@code AbstractTypes} instance.
     *
     * @param element element
     * @throws NullPointerException if the argument is null
     * @throws IllegalArgumentException if the given {@link Element} cannot be used with this class
     */
    protected abstract void requireValidElement(Element element);

    /**
     * Verifies that the given {@link TypeMirror} is valid for use with this class, or that it is {@code null}.
     *
     * &lt;p&gt;The meaning of valid is implementation-defined, but typically a valid {@link TypeMirror} must have been
     * created by the implementation that belongs to the current {@code AbstractTypes} instance. A {@code null} argument
     * is always valid. The rationale is that {@code null} {@link TypeMirror} arguments have a special meaning for some
     * methods such as {@link #getWildcardType(TypeMirror, TypeMirror)} or
     * {@link #createTypeVariable(TypeParameterElement, WildcardType)}.
     *
     * @param type type mirror, may be {@code null}
     * @throws IllegalArgumentException if the given {@link TypeMirror} instance is non-null and it cannot be used with
     *     this class
     */
    protected abstract void requireValidType(@Nullable TypeMirror type);

    /**
     * Verifies that the given array is non-null and contains valid types that are not null.
     *
     * @param types array of types
     * @throws NullPointerException if the given array or any of its elements are null
     * @throws IllegalArgumentException if {@link #requireValidType(TypeMirror)} throws an exception for one of the
     *     array elements
     */
    protected final void requireValidTypes(TypeMirror[] types) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (TypeMirror typeArg: types) {</span>
<span class="fc" id="L107">            Objects.requireNonNull(typeArg, &quot;TypeMirror array must not contain null elements.&quot;);</span>
<span class="fc" id="L108">            requireValidType(typeArg);</span>
        }
<span class="fc" id="L110">    }</span>

    /**
     * Returns a type mirror corresponding to the given Java reflection type.
     *
     * &lt;p&gt;Subclasses are required to return the appropriate {@link DeclaredType} instances for the following
     * {@link Class} instances:
     * &lt;ul&gt;&lt;li&gt;
     *     {@link Object}
     * &lt;/li&gt;&lt;li&gt;
     *     {@link Serializable}
     * &lt;/li&gt;&lt;li&gt;
     *     {@link Cloneable}
     * &lt;/li&gt;&lt;/ul&gt;
     *
     * &lt;p&gt;Support for other types is not required and implementation-defined.
     *
     * @param type type as represented by Java Reflection API
     * @throws UnsupportedOperationException If the given type is not one of the above {@link Class} objects and
     *     this type-utilities implementation does not support mirroring arbitrary Java reflection types.
     * @return the type mirror corresponding to the given reflection type
     */
    protected abstract TypeMirror typeMirror(Type type);

    /**
     * Internal class that contains both the substitution map passed to {@link #substitute(TypeMirror, Map)} and the
     * set of fresh type variables created at the beginning of that method.
     */
    private static final class Substitutions {
        private final Map&lt;TypeParameterElement, ? extends TypeMirror&gt; map;
        private final Map&lt;TypeParameterElement, TypeVariable&gt; freshTypeVariables;

        private Substitutions(Map&lt;TypeParameterElement, ? extends TypeMirror&gt; map,
<span class="fc" id="L143">                Map&lt;TypeParameterElement, TypeVariable&gt; freshTypeVariables) {</span>
<span class="fc" id="L144">            this.map = map;</span>
<span class="fc" id="L145">            this.freshTypeVariables = freshTypeVariables;</span>
<span class="fc" id="L146">        }</span>
    }

    /**
     * Visitor of a type mirror. Returns a new type mirror after performing the substitutions passed as visitor
     * argument.
     *
     * &lt;p&gt;This visitor is only used within this class and only on &lt;em&gt;valid&lt;/em&gt; {@link TypeMirror} instances. Hence, it
     * can be asserted that the visitor parameter is always non-null.
     *
     * @see #substitutionVisitor
     * @see #requireValidType(TypeMirror)
     */
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">    private final class SubstitutionVisitor extends ExtendedTypeKindVisitor7&lt;TypeMirror, Substitutions&gt; {</span>
        private TypeMirror[] substituteInList(List&lt;? extends TypeMirror&gt; types, Substitutions substitutions) {
<span class="fc" id="L161">            TypeMirror[] substituted = new TypeMirror[types.size()];</span>
<span class="fc" id="L162">            int i = 0;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            for (TypeMirror type: types) {</span>
<span class="fc" id="L164">                substituted[i] = type.accept(this, substitutions);</span>
<span class="fc" id="L165">                ++i;</span>
<span class="fc" id="L166">            }</span>
<span class="fc" id="L167">            return substituted;</span>
        }

        @Override
        public TypeMirror visitDeclared(DeclaredType declaredType, @Nullable Substitutions substitutions) {
<span class="pc bpc" id="L172" title="2 of 4 branches missed.">            assert substitutions != null;</span>
<span class="fc" id="L173">            TypeMirror enclosingType = declaredType.getEnclosingType();</span>
<span class="fc" id="L174">            TypeElement typeDeclaration = (TypeElement) declaredType.asElement();</span>
<span class="fc" id="L175">            TypeMirror[] substitutedArguments = substituteInList(declaredType.getTypeArguments(), substitutions);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            if (enclosingType.getKind() == TypeKind.DECLARED) {</span>
<span class="fc" id="L177">                return getDeclaredType((DeclaredType) enclosingType, typeDeclaration, substitutedArguments);</span>
            } else {
<span class="fc" id="L179">                return getDeclaredType(typeDeclaration, substitutedArguments);</span>
            }
        }

        @Override
        public TypeMirror visitArray(ArrayType arrayType, @Nullable Substitutions substitutions) {
<span class="pc bpc" id="L185" title="2 of 4 branches missed.">            assert substitutions != null;</span>
<span class="fc" id="L186">            return getArrayType(arrayType.getComponentType().accept(this, substitutions));</span>
        }

        @Override
        public TypeMirror visitTypeVariable(TypeVariable typeVariable, @Nullable Substitutions substitutions) {
<span class="pc bpc" id="L191" title="2 of 4 branches missed.">            assert substitutions != null;</span>
<span class="fc" id="L192">            TypeParameterElement formalTypeParameter = (TypeParameterElement) typeVariable.asElement();</span>
<span class="fc" id="L193">            @Nullable TypeVariable freshTypeVariable = substitutions.freshTypeVariables.get(formalTypeParameter);</span>
<span class="pc bpc" id="L194" title="1 of 4 branches missed.">            if (freshTypeVariable != null &amp;&amp; formalTypeParameter.asType().equals(typeVariable)) {</span>
<span class="fc" id="L195">                return freshTypeVariable;</span>
            }

<span class="fc" id="L198">            @Nullable TypeMirror substitution = substitutions.map.get(formalTypeParameter);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">            if (substitution != null) {</span>
<span class="fc" id="L200">                return substitution;</span>
            }

<span class="fc" id="L203">            return getTypeVariable(</span>
                formalTypeParameter,
<span class="fc" id="L205">                typeVariable.getUpperBound().accept(this, substitutions),</span>
<span class="fc" id="L206">                typeVariable.getLowerBound().accept(this, substitutions),</span>
<span class="fc" id="L207">                capturedTypeArgument(typeVariable)</span>
            );
        }

        @Override
        public TypeMirror visitWildcard(WildcardType wildcardType, @Nullable Substitutions substitutions) {
<span class="pc bpc" id="L213" title="2 of 4 branches missed.">            assert substitutions != null;</span>
<span class="fc" id="L214">            @Nullable TypeMirror extendsBounds = wildcardType.getExtendsBound();</span>
<span class="fc" id="L215">            @Nullable TypeMirror superBound = wildcardType.getSuperBound();</span>

<span class="fc bfc" id="L217" title="All 2 branches covered.">            return getWildcardType(</span>
                extendsBounds != null
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">                    ? extendsBounds.accept(this, substitutions)</span>
                    : null,
                superBound != null
<span class="pc" id="L222">                    ? superBound.accept(this, substitutions)</span>
                    : null
            );
        }

        @Override
        public TypeMirror visitIntersection(IntersectionType intersectionType, @Nullable Substitutions substitutions) {
<span class="pc bpc" id="L229" title="2 of 4 branches missed.">            assert substitutions != null;</span>
<span class="fc" id="L230">            return getIntersectionType(substituteInList(intersectionType.getBounds(), substitutions));</span>
        }

        @Override
        protected TypeMirror defaultAction(TypeMirror type, Substitutions substitutions) {
<span class="fc" id="L235">            return type;</span>
        }
    }

    /**
     * Replaces formal type parameters in the given type.
     *
     * &lt;p&gt;This method requires that {@code type} does not contain transitive references to itself, unless through
     * {@link DeclaredType#asElement()} → {@link TypeElement#asType()} or {@link TypeVariable#asElement()} →
     * {@link TypeParameterElement#asType()}. Otherwise, this method might run into an infinite recursion, resulting in
     * a {@link StackOverflowError}.
     *
     * &lt;p&gt;Moreover, this method requires that any type variable transitively referenced by {@code substitutionMap} must
     * not contain a transitive reference (through {@link TypeVariable#getUpperBound()} or
     * {@link TypeVariable#getLowerBound()}) to itself. Instead, any instance of {@link TypeVariable} (transitively)
     * referenced by a value in {@code substitutionMap} must be the result of {@link TypeParameterElement#asType()}.
     *
     * &lt;p&gt;This method creates a fresh type variable for each formal type parameter that is to be substituted by a type
     * variable for the same formal type parameter. For instance, suppose {@code T extends Object} is a formal type
     * parameter, and {@code substitutionMap} specifies to replace it with the type variable {@code T extends U&lt;T&gt;}. In
     * this case, {@link #createTypeVariable(TypeParameterElement, WildcardType)} will be called with the formal type
     * parameter {@code T extends Object} as (first) argument. Once all fresh types have been created,
     * {@link #setTypeVariableBounds(TypeVariable, TypeMirror, TypeMirror)} will then be called with {@code U&lt;T&gt;} as
     * upper bound, where {@code T} is the fresh type variable {@code T extends U&lt;T&gt;}.
     *
     * @param type type in which the type parameters will be replaced recursively, guaranteed non-null
     * @param substitutionMap mapping from formal type parameters to substituted type, guaranteed non-null
     * @return new port type, guaranteed non-null
     */
    protected TypeMirror substitute(TypeMirror type, Map&lt;TypeParameterElement, ? extends TypeMirror&gt; substitutionMap) {
<span class="fc" id="L265">        Objects.requireNonNull(type);</span>
<span class="fc" id="L266">        Objects.requireNonNull(substitutionMap);</span>
<span class="fc" id="L267">        requireValidType(type);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        for (TypeMirror substitutionType: substitutionMap.values()) {</span>
<span class="fc" id="L269">            Objects.requireNonNull(substitutionType, &quot;Substitution type cannot be null.&quot;);</span>
<span class="fc" id="L270">            requireValidType(substitutionType);</span>
<span class="fc" id="L271">        }</span>

<span class="fc" id="L273">        Map&lt;TypeParameterElement, TypeVariable&gt; freshTypeVariables = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (Map.Entry&lt;TypeParameterElement, ? extends TypeMirror&gt; entry: substitutionMap.entrySet()) {</span>
<span class="fc" id="L275">            TypeMirror value = entry.getValue();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            if (value.getKind() == TypeKind.TYPEVAR) {</span>
<span class="fc" id="L277">                TypeParameterElement formalTypeParameter = entry.getKey();</span>
<span class="fc" id="L278">                TypeVariable typeVariable = (TypeVariable) value;</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                if (entry.getKey().equals(typeVariable.asElement())) {</span>
<span class="pc bpc" id="L280" title="2 of 4 branches missed.">                    assert !freshTypeVariables.containsKey(formalTypeParameter);</span>

<span class="fc" id="L282">                    freshTypeVariables.put(</span>
                        formalTypeParameter,
<span class="fc" id="L284">                        createTypeVariable(formalTypeParameter, capturedTypeArgument(typeVariable))</span>
                    );
                }
            }
<span class="fc" id="L288">        }</span>

<span class="fc" id="L290">        Substitutions substitutions = new Substitutions(substitutionMap, freshTypeVariables);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        for (Map.Entry&lt;TypeParameterElement, TypeVariable&gt; entry: freshTypeVariables.entrySet()) {</span>
<span class="fc" id="L292">            TypeVariable substitution = (TypeVariable) substitutionMap.get(entry.getKey());</span>
<span class="fc" id="L293">            setTypeVariableBounds(</span>
<span class="fc" id="L294">                entry.getValue(),</span>
<span class="fc" id="L295">                substitution.getUpperBound().accept(substitutionVisitor, substitutions),</span>
<span class="fc" id="L296">                substitution.getLowerBound().accept(substitutionVisitor, substitutions)</span>
            );
<span class="fc" id="L298">        }</span>

<span class="fc" id="L300">        return type.accept(substitutionVisitor, substitutions);</span>
    }

    /**
     * Returns the actual type arguments of a type declaration given a subtype (typically with its own actual type
     * arguments).
     *
     * &lt;p&gt;This method &quot;projects&quot; the actual type arguments of {@code subtype}, as well as all actual type arguments of
     * super types in the type hierarchy between {@code typeElement} and {@code subType}, onto the type declaration
     * represented by {@code typeElement}.
     *
     * &lt;p&gt;For example, {@code typeElement} may be the (generic) type declaration {@code Comparable&lt;T&gt;}, and
     * {@code subType} may be the (non-generic) type {@link Integer}. The result in this case would be a singleton list
     * containing the type {@link Integer}.
     *
     * &lt;p&gt;More generally, resolution works as follows: First, the shortest inheritance path from {@code subType} to
     * {@code typeElement} is found. Note that while Java allows multiple inheritance for interfaces, JLS §8.1.5
     * disallows inheriting from the same interface with different type parameters (both directly and transitively).
     * Hence, the shortest path contains all information that is necessary to resolve formal type parameters to actual
     * parameters. This method then propagates the actual type arguments bottom-up along the inheritance path.
     * Note that the inheritance path consists of {@link DeclaredType} instances, and it may consist of generic types,
     * non-generic types, and raw types.
     *
     * &lt;p&gt;If the inheritance path contains a raw type &lt;em&gt;before&lt;/em&gt; the last path element, this method proceeds
     * by using the &quot;prototypical&quot; type returned by {@link Element#asType()} instead. Correspondingly, it is possible
     * that the returned list may contain type variables from a type declaration along the inheritance path. However, if
     * the &lt;em&gt;last&lt;/em&gt; inheritance path element is a raw type, the returned list will be empty. Otherwise, if a
     * non-null non-empty {@link List} is returned, it is guaranteed to have the same number of elements as
     * {@code typeElement.getTypeParameters()}.
     *
     * @param typeElement type declaration
     * @param subType potential subtype of {@code typeElement}, must be a non-generic type declaration, raw type,
     *     generic type declaration, or parameterized type
     * @return actual type arguments for the formal parameters of {@code typeElement} (empty list if the &lt;em&gt;last&lt;/em&gt;
     *     path element in the inheritance path from {@code subType} to {@code typeElement} is a raw type), or
     *     {@code null} if {@code subType} is not a subtype of {@code typeElement}
     * @throws IllegalArgumentException if the arguments do not satisfy the constraints mentioned above
     */
    @Nullable
    public final List&lt;? extends TypeMirror&gt; resolveActualTypeArguments(TypeElement typeElement, TypeMirror subType) {
<span class="fc" id="L340">        requireValidElement(Objects.requireNonNull(typeElement));</span>
<span class="fc" id="L341">        requireValidType(Objects.requireNonNull(subType));</span>

<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (subType.getKind() != TypeKind.DECLARED) {</span>
<span class="fc" id="L344">            return null;</span>
        }

<span class="fc" id="L347">        DeclaredType declaredSubType = (DeclaredType) subType;</span>

        // getShortestPathToSuperType() will throw an exception if subType does not satisfy the constraints mentioned
        // above.
<span class="fc" id="L351">        @Nullable List&lt;DeclaredType&gt; path = getShortestPathToSuperType(typeElement, declaredSubType);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        if (path == null) {</span>
<span class="fc" id="L353">            return null;</span>
        }

        // Early exit if there is nothing to resolve. However, we must not move this early exit any earlier, because
        // we do want to return null if subType is not a subtype of typeElement.
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (typeElement.getTypeParameters().isEmpty()) {</span>
<span class="fc" id="L359">            return Collections.emptyList();</span>
        }

<span class="fc" id="L362">        Iterator&lt;DeclaredType&gt; pathIterator = path.iterator();</span>
<span class="fc" id="L363">        DeclaredType current = pathIterator.next();</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        while (pathIterator.hasNext()) {</span>
<span class="fc" id="L365">            TypeElement currentTypeElement = (TypeElement) current.asElement();</span>

            // Check whether &quot;current&quot; is a raw type. This may happen in the first loop iteration if subType is a raw
            // type, or in subsequent iterations if the type that was previously &quot;current&quot; (during the last iteration
            // of the for-loop) derived from a raw type. If yes, use instead the &quot;prototypical&quot; type returned by
            // Element#asType().
<span class="fc bfc" id="L371" title="All 4 branches covered.">            if (current.getTypeArguments().isEmpty() &amp;&amp; !currentTypeElement.getTypeParameters().isEmpty()) {</span>
<span class="fc" id="L372">                current = (DeclaredType) currentTypeElement.asType();</span>
            }

<span class="fc" id="L375">            List&lt;? extends TypeParameterElement&gt; currentFormalParameters = currentTypeElement.getTypeParameters();</span>
<span class="fc" id="L376">            List&lt;? extends TypeMirror&gt; currentActualParameters = current.getTypeArguments();</span>

<span class="fc" id="L378">            Map&lt;TypeParameterElement, TypeMirror&gt; currentFormalToActual = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">            for (int index = 0; index &lt; currentFormalParameters.size(); ++index) {</span>
<span class="fc" id="L380">                currentFormalToActual.put(currentFormalParameters.get(index), currentActualParameters.get(index));</span>
            }

<span class="fc" id="L383">            current = (DeclaredType) substitute(pathIterator.next(), currentFormalToActual);</span>
<span class="fc" id="L384">        }</span>
<span class="fc" id="L385">        return current.getTypeArguments();</span>
    }

    /**
     * Visitor of a type mirror. Returns whether the visited type mirror is a subtype of the visitor argument (of type
     * {@link DeclaredType}).
     *
     * &lt;p&gt;This visitor is only used within this class and only on &lt;em&gt;valid&lt;/em&gt; {@link TypeMirror} instances. Hence, it
     * can be asserted that the visitor parameter is always non-null.
     *
     * @see #declaredTypeSubtypeVisitor
     * @see #requireValidType(TypeMirror)
     */
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">    private final class DeclaredTypeSubtypeVisitor extends ExtendedTypeKindVisitor7&lt;Boolean, DeclaredType&gt; {</span>
<span class="fc" id="L399">        private DeclaredTypeSubtypeVisitor() {</span>
<span class="fc" id="L400">            super(false);</span>
<span class="fc" id="L401">        }</span>

        /**
         * Returns whether the first declared type is a subtype of the second declared type.
         *
         * &lt;p&gt;This method proceeds by computing the actual type arguments when {@code subType} is projected onto the
         * type declaration corresponding to {@code superType}. It then tests if all actual type arguments of
         * {@code subType} are &lt;em&gt;contained&lt;/em&gt; in those of {@code superType}.
         */
        @Override
        public Boolean visitDeclared(DeclaredType subType, @Nullable DeclaredType superType) {
<span class="pc bpc" id="L412" title="2 of 4 branches missed.">            assert superType != null;</span>
<span class="fc" id="L413">            DeclaredType actualSubType = subType;</span>

            // First test if there subType has at least one wildcard type argument. In that case, we need to perform a
            // capture conversion first.
            // Note that this is the right place to do capture conversion: JLS §8.1.4 and §9.1.3 state about class types
            // and interfaces type listed in the extends or implements clause of a class/interface declaration:
            // - &quot;If the ClassType has type arguments, it must denote a well-formed parameterized type (§4.5), and none
            // of the type arguments may be wildcard type arguments, or a compile-time error occurs.&quot;
            // - &quot;If an InterfaceType has type arguments, it must denote a well-formed parameterized type (§4.5), and
            // none of the type arguments may be wildcard type arguments, or a compile-time error occurs.&quot;
            // Hence, wildcards do not appear on the &quot;inheritance path&quot; between subType and superType.
<span class="fc bfc" id="L424" title="All 2 branches covered.">            for (TypeMirror subTypeArgument: subType.getTypeArguments()) {</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">                if (subTypeArgument.getKind() == TypeKind.WILDCARD) {</span>
<span class="fc" id="L426">                    actualSubType = (DeclaredType) capture(subType);</span>
<span class="fc" id="L427">                    break;</span>
                }
<span class="fc" id="L429">            }</span>

            // Resolve the actual type parameters of subType when projected onto the superType
<span class="fc" id="L432">            TypeElement superTypeDeclaration = (TypeElement) superType.asElement();</span>
<span class="fc" id="L433">            @Nullable List&lt;? extends TypeMirror&gt; projectedTypeArguments</span>
<span class="fc" id="L434">                = resolveActualTypeArguments(superTypeDeclaration, actualSubType);</span>

<span class="fc bfc" id="L436" title="All 2 branches covered.">            if (projectedTypeArguments == null) {</span>
                // subType is not a subtype of the type declaration
<span class="fc" id="L438">                return false;</span>
            }

<span class="fc" id="L441">            List&lt;? extends TypeMirror&gt; superTypeArguments = superType.getTypeArguments();</span>
<span class="fc bfc" id="L442" title="All 4 branches covered.">            if (projectedTypeArguments.isEmpty() &amp;&amp; !superTypeArguments.isEmpty()) {</span>
                // the projection of subType onto superType resulted in a raw type, which is neither a subtype of any
                // parametrized type of the generic type declaration of superType, nor the generic type declaration
                // itself
<span class="fc" id="L446">                return false;</span>
            }

            // Note that superType could be a raw type, in which case superTypeArguments is empty. In that case, the
            // loop would not be executed at all.
<span class="fc" id="L451">            Iterator&lt;? extends TypeMirror&gt; projectedTypeArgumentsIterator = projectedTypeArguments.iterator();</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">            for (TypeMirror to: superTypeArguments) {</span>
<span class="fc" id="L453">                TypeMirror from = projectedTypeArgumentsIterator.next();</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">                if (!contains(to, from)) {</span>
<span class="fc" id="L455">                    return false;</span>
                }
<span class="fc" id="L457">            }</span>
<span class="fc" id="L458">            return true;</span>
        }

        /**
         * Returns whether the array type is a subtype of the declared type.
         *
         * &lt;p&gt;According to JLS §4.10.3, an array type can only be a subtype of a declared type if the latter represents
         * one of {@link Object}, {@link Cloneable}, or {@link Serializable}.
         */
        @Override
        public Boolean visitArray(ArrayType subType, @Nullable DeclaredType superType) {
<span class="pc bpc" id="L469" title="2 of 4 branches missed.">            assert superType != null;</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">            return typeMirror(Object.class).equals(superType)</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">                || typeMirror(Cloneable.class).equals(superType)</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">                || typeMirror(Serializable.class).equals(superType);</span>
        }

        /**
         * Returns whether the type variable is a subtype of the declared type.
         *
         * &lt;p&gt;According to JLS §4.10.2, the direct supertypes of a type variable are the types listed in its bound.
         * Hence, this method returns true if {@link TypeVariable#getUpperBound()} is a subtype of {@code superType}.
         */
        @Override
        public Boolean visitTypeVariable(TypeVariable subType, @Nullable DeclaredType superType) {
<span class="pc bpc" id="L483" title="2 of 4 branches missed.">            assert superType != null;</span>
<span class="fc" id="L484">            return isSubtype(subType.getUpperBound(), superType);</span>
        }

        /**
         * Returns whether the intersection type is a subtype of the declared type.
         *
         * &lt;p&gt;According to JLS §4.10.2, the direct supertypes of an intersection type {@code T_1 &amp; ... T_n} are
         * {@code T_1}, ..., {@code T_n}. Hence, this method returns true if at least one of
         * {@link IntersectionType#getBounds()} is a subtype of {@code superType}.
         */
        @Override
        public Boolean visitIntersection(IntersectionType subType, @Nullable DeclaredType superType) {
<span class="pc bpc" id="L496" title="2 of 4 branches missed.">            assert superType != null;</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">            for (TypeMirror bound: subType.getBounds()) {</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">                if (isSubtype(bound, superType)) {</span>
<span class="fc" id="L499">                    return true;</span>
                }
<span class="fc" id="L501">            }</span>
<span class="fc" id="L502">            return false;</span>
        }
    }

    /**
     * Visitor of a type mirror. Returns whether the visited type mirror is a supertype of the visitor argument.
     *
     * &lt;p&gt;This visitor does not have to deal with the null-type, which has been dealt with before. It has to make a
     * decision for {@link ArrayType}, {@link DeclaredType}, {@link PrimitiveType}, and {@link TypeVariable}.
     *
     * &lt;p&gt;Java 8 introduces {@code IntersectionType}, but this code currently uses Java 7. Moreover, there are other
     * types that are currently not supported, such as {@link javax.lang.model.type.UnionType}. Finally,
     * {@link WildcardType} is not a type, but only a type argument, so it is not necessary to be dealt with here.
     * Likewise, {@link NoType} is not used to model proper types, but only empty bounds, non-existence of interface
     * super classes, etc.
     *
     * &lt;p&gt;This visitor is only used within this class and only on &lt;em&gt;valid&lt;/em&gt; {@link TypeMirror} instances. Hence, it
     * can be asserted that the visitor parameter is always non-null.
     *
     * @see #subtypeVisitor
     * @see #requireValidType(TypeMirror)
     */
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">    private final class SubtypeVisitor extends ExtendedTypeKindVisitor7&lt;Boolean, TypeMirror&gt; {</span>
<span class="fc" id="L525">        private SubtypeVisitor() {</span>
<span class="fc" id="L526">            super(false);</span>
<span class="fc" id="L527">        }</span>

        /**
         * Returns whether the array type is a super type of the type given as second argument.
         *
         * &lt;p&gt;According to JLS §4.10.3, array component types are covariant; for instance, {@code Integer[]} is a proper
         * subtype of {@code Number[]}. Moreover, all subtypes of an array type are again array types. Hence, this
         * method simply reduces the problem to testing if {@code subType} is also an array type and then applying
         * {@link AbstractTypes#isSubtype(TypeMirror, TypeMirror)} to the component types.
         */
        @Override
        public Boolean visitArray(ArrayType superType, @Nullable TypeMirror subType) {
<span class="pc bpc" id="L539" title="2 of 4 branches missed.">            assert subType != null;</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            return subType.getKind() == TypeKind.ARRAY</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">                &amp;&amp; isSubtype(((ArrayType) subType).getComponentType(), superType.getComponentType());</span>
        }

        /**
         * Returns whether the declared type is a super type of the type given as second argument.
         *
         * &lt;p&gt;This method has {@link DeclaredTypeSubtypeVisitor} visit {@code subType}.
         */
        @Override
        public Boolean visitDeclared(DeclaredType superType, @Nullable TypeMirror subType) {
<span class="pc bpc" id="L551" title="2 of 4 branches missed.">            assert subType != null;</span>
<span class="fc" id="L552">            return subType.accept(declaredTypeSubtypeVisitor, superType);</span>
        }

<span class="fc" id="L555">        private final List&lt;TypeKind&gt; numericKindEnumValues = Collections.unmodifiableList(Arrays.asList(</span>
            TypeKind.DOUBLE, TypeKind.FLOAT, TypeKind.LONG, TypeKind.INT, TypeKind.SHORT, TypeKind.BYTE
        ));
<span class="fc" id="L558">        private final int intIndex = numericKindEnumValues.indexOf(TypeKind.INT);</span>

        /**
         * Returns whether the primitive type is a supertype of the given type.
         */
        @Override
        public Boolean visitPrimitive(PrimitiveType superType, @Nullable TypeMirror subType) {
<span class="pc bpc" id="L565" title="2 of 4 branches missed.">            assert subType != null;</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">            if (!subType.getKind().isPrimitive()) {</span>
<span class="fc" id="L567">                return false;</span>
            }

<span class="fc" id="L570">            int superTypeIndex = numericKindEnumValues.indexOf(superType.getKind());</span>
<span class="fc" id="L571">            int subTypeIndex = numericKindEnumValues.indexOf(subType.getKind());</span>
<span class="pc bpc" id="L572" title="1 of 10 branches missed.">            return (subType.getKind() == TypeKind.CHAR &amp;&amp; 0 &lt;= superTypeIndex &amp;&amp; superTypeIndex &lt;= intIndex)</span>
                || (0 &lt;= superTypeIndex &amp;&amp; superTypeIndex &lt;= subTypeIndex);
        }

        /**
         * Returns whether the type variable is a super type of the given type.
         *
         * &lt;p&gt;A type variable is only a supertype of its lower bound.
         */
        @Override
        public Boolean visitTypeVariable(TypeVariable superType, @Nullable TypeMirror subType) {
<span class="pc bpc" id="L583" title="2 of 4 branches missed.">            assert subType != null;</span>
<span class="fc" id="L584">            return isSameType(superType.getLowerBound(), subType);</span>
        }

        /**
         * Returns whether the given intersection type is a super type of the given type.
         *
         * &lt;p&gt;While one might expect that the set of supertypes of an intersection type {@code T_1 &amp; ... &amp; T_n} includes
         * the intersection of any (non-empty) subset of {@code T_1}, ..., {@code T_n}, this seems is not specified by
         * JLS §4.10 (which only says that &quot;the direct supertypes of an intersection type {@code T_1 &amp; ... &amp; T_n} are
         * {@code T_i} (1 ≤ i ≤ n)&quot;). See also issue
         * &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6718388&quot;&gt;JDK-6718388&lt;/a&gt;.
         *
         * &lt;p&gt;Therefore, an intersection type is only a supertype of itself.
         */
        @Override
        public Boolean visitIntersection(IntersectionType superType, @Nullable TypeMirror subType) {
<span class="pc bpc" id="L600" title="2 of 4 branches missed.">            assert subType != null;</span>
<span class="fc" id="L601">            return isSameType(superType, subType);</span>
        }
    }

    /**
     * Returns whether the first type is a subtype of the second type, as specified by JLS §4.10.
     *
     * &lt;p&gt;The subtype relationship is transitive and reflexive.
     *
     * @param t1 the first type
     * @param t2 the second type
     * @return {@code true} if and only if the first type is a subtype of the second
     * @throws NullPointerException if an argument is null
     * @throws IllegalArgumentException if given an executable or package type
     */
    @Override
    public final boolean isSubtype(TypeMirror t1, TypeMirror t2) {
<span class="fc" id="L618">        requireValidType(Objects.requireNonNull(t1));</span>
<span class="fc" id="L619">        requireValidType(Objects.requireNonNull(t2));</span>

        // §4.10.2: The direct supertypes of the null type are all reference types other than the null type itself.
<span class="fc bfc" id="L622" title="All 4 branches covered.">        if (t1.getKind() == TypeKind.NULL &amp;&amp; REFERENCE_TYPES.contains(t2.getKind())) {</span>
<span class="fc" id="L623">            return true;</span>
        }

<span class="fc" id="L626">        return t2.accept(subtypeVisitor, t1);</span>
    }

    /**
     * Returns whether the first type argument &lt;em&gt;contains&lt;/em&gt; the second type argument, as specified by JLS §4.5.1.
     *
     * &lt;p&gt;Using the JLS notation, this method returns true if {@code t2 &lt;= t1}. As JLS §4.10 states, &quot;subtyping does not
     * extend through parameterized types.&quot; Hence, this method is necessarily different from
     * {@link #isSubtype(TypeMirror, TypeMirror)}. In particular, the super-type relationship does not include types
     * with covariant type arguments.
     *
     * @param t1 the first type
     * @param t2 the second type
     * @return {@code true} if and only if the first type contains the second
     * @throws IllegalArgumentException if given an executable or package type
     */
    @Override
    public final boolean contains(TypeMirror t1, TypeMirror t2) {
<span class="fc" id="L644">        Objects.requireNonNull(t1);</span>
<span class="fc" id="L645">        Objects.requireNonNull(t2);</span>
<span class="fc" id="L646">        requireValidType(t1);</span>
<span class="fc" id="L647">        requireValidType(t2);</span>

        // We need to cover these cases (JLS §4.5.1):
        //
        // (a) wildcard t2 &lt;= wildcard t1
        // 1. ? extends T &lt;= ? extends S if T &lt;: S
        // 2. ? extends T &lt;= ?
        // 3. ? super T &lt;= ? super S if S &lt;: T
        // 4. ? super T &lt;= ?
        // 5. ? super T &lt;= ? extends Object
        //
        // (b) other type t2 &lt;= other type t1
        // 1. T &lt;= T
        //
        // (c) other type t2 &lt;= wildcard t1
        // 1. T &lt;= ? extends T
        // 2. T &lt;= ? super T

<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (t1.getKind() == TypeKind.WILDCARD) {</span>
<span class="fc" id="L666">            @Nullable TypeMirror t1ExtendsBound = ((WildcardType) t1).getExtendsBound();</span>
<span class="fc" id="L667">            @Nullable TypeMirror t1SuperBound = ((WildcardType) t1).getSuperBound();</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">            boolean t1HasExtendsBound = t1ExtendsBound != null;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">            boolean t1HasSuperBound = t1SuperBound != null;</span>

<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (t2.getKind() == TypeKind.WILDCARD) {</span>
                // Handle (a).
<span class="fc" id="L673">                @Nullable TypeMirror t2ExtendsBound = ((WildcardType) t2).getExtendsBound();</span>
<span class="fc" id="L674">                @Nullable TypeMirror t2SuperBound = ((WildcardType) t2).getSuperBound();</span>

<span class="fc bfc" id="L676" title="All 2 branches covered.">                if (t2ExtendsBound != null) {</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">                    if (t1ExtendsBound != null) {</span>
                        // (a) 1.
<span class="fc" id="L679">                        return isSubtype(t2ExtendsBound, t1ExtendsBound);</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">                    } else if (t1SuperBound == null) {</span>
                        // (a) 2.
<span class="fc" id="L682">                        return true;</span>
                    }
                    // Note that &quot;? super S&quot; never contains a type argument of form &quot;? extends T&quot;
<span class="fc" id="L685">                    return false;</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">                } else if (t2SuperBound != null) {</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">                    if (t1SuperBound != null) {</span>
                        // (a) 3.
<span class="fc" id="L689">                        return isSubtype(t1SuperBound, t2SuperBound);</span>
                    } else {
                        // (a) 4. and 5.: Handle case &quot;? super T &lt;= ?&quot; (always true) or &quot;? super S &lt;= ? extends T&quot; (only
                        // if T is Object)
<span class="fc bfc" id="L693" title="All 2 branches covered.">                        return t1ExtendsBound == null</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">                            || isSameType(t1ExtendsBound, typeMirror(Object.class));</span>
                    }
                } else {
                    // Handle special case of (a), namely &quot;? &lt;= ? extends T&quot; (only if T is Object), &quot;? &lt;= ? super T&quot;
                    // (always false), or &quot;? &lt;= ?&quot; (which is equivalent to &quot;? extends Object &lt;= ? extends Object&quot; and
                    // therefore true).
<span class="fc bfc" id="L700" title="All 4 branches covered.">                    return t1SuperBound == null &amp;&amp; (</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">                        t1ExtendsBound == null || isSameType(t1ExtendsBound, typeMirror(Object.class))</span>
                    );
                }
            } else {
                // Handle (c). Reduce to case (a).
<span class="fc bfc" id="L706" title="All 2 branches covered.">                if (t1HasExtendsBound) {</span>
                    // (c) 1.
<span class="fc" id="L708">                    return contains(t1, getWildcardType(t2, null));</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">                } else if (t1HasSuperBound) {</span>
                    // (c) 2.
<span class="fc" id="L711">                    return contains(t1, getWildcardType(null, t2));</span>
                }
                // Combining (c) 1. with (a) 2. or (c) 2. with (a) 4., we immediately have &quot;T &lt;= ?&quot;
<span class="fc" id="L714">                return true;</span>
            }
        } else {
            // Handle (b).
<span class="fc" id="L718">            return isSameType(t1, t2);</span>
        }
    }

    /**
     * Returns the direct super types of the given type declaration, as defined by JLS §4.10.2.
     */
    private List&lt;DeclaredType&gt; directSupertypesOfTypeDeclaration(TypeElement typeElement) {
<span class="fc" id="L726">        TypeMirror superClass = typeElement.getSuperclass();</span>
<span class="fc" id="L727">        List&lt;? extends TypeMirror&gt; interfaces = typeElement.getInterfaces();</span>
<span class="fc" id="L728">        List&lt;DeclaredType&gt; newSuperTypes = new ArrayList&lt;&gt;(1 + interfaces.size());</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        if (superClass.getKind() == TypeKind.DECLARED) {</span>
<span class="fc" id="L730">            newSuperTypes.add((DeclaredType) superClass);</span>
        }
<span class="fc bfc" id="L732" title="All 2 branches covered.">        for (TypeMirror superInterface: interfaces) {</span>
<span class="fc" id="L733">            newSuperTypes.add((DeclaredType) superInterface);</span>
<span class="fc" id="L734">        }</span>
<span class="fc bfc" id="L735" title="All 4 branches covered.">        if (typeElement.getKind() == ElementKind.INTERFACE &amp;&amp; interfaces.isEmpty()) {</span>
<span class="fc" id="L736">            newSuperTypes.add((DeclaredType) typeMirror(Object.class));</span>
        }
<span class="fc" id="L738">        return newSuperTypes;</span>
    }

    /**
     * Internal class to keep state for the Dijkstra shortest-path algorithm in
     * {@link #getShortestPathToSuperType(TypeElement, DeclaredType)}.
     */
    private static final class TypeDeclarationVertexState {
        private int distance;
        private boolean visited;
        private final TypeElement typeElement;

        /**
         * The type as contained in {@code previous.typeDeclaration.getSuperTypes()}.
         */
        private final DeclaredType declaredType;

        @Nullable private TypeDeclarationVertexState previous;

        private TypeDeclarationVertexState(int distance, boolean visited, TypeElement typeElement,
<span class="fc" id="L758">                DeclaredType declaredType) {</span>
<span class="fc" id="L759">            this.distance = distance;</span>
<span class="fc" id="L760">            this.visited = visited;</span>
<span class="fc" id="L761">            this.typeElement = typeElement;</span>
<span class="fc" id="L762">            this.declaredType = declaredType;</span>
<span class="fc" id="L763">        }</span>

        /**
         * Returns the path induced by this node, starting with {@code derived} and ending with {@link #declaredType}.
         *
         * &lt;p&gt;The path is obtained by following {@link #previous} until {@code null}. Each element in the path (except
         * for the first) is the {@link #declaredType} of the current instance.
         *
         * @param derived the first element in the path
         * @return the path induced by this node
         */
        private List&lt;DeclaredType&gt; toPath(DeclaredType derived) {
<span class="fc" id="L775">            DeclaredType[] path = new DeclaredType[distance + 1];</span>
<span class="fc" id="L776">            int count = path.length;</span>
<span class="fc" id="L777">            TypeDeclarationVertexState pathElement = this;</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">            while (pathElement.previous != null) {</span>
<span class="fc" id="L779">                --count;</span>
<span class="fc" id="L780">                path[count] = pathElement.declaredType;</span>
<span class="fc" id="L781">                pathElement = pathElement.previous;</span>
            }
<span class="fc" id="L783">            path[0] = derived;</span>
<span class="fc" id="L784">            return Arrays.asList(path);</span>
        }
    }

    /**
     * Returns the shortest inheritance path between a type declaration and a subtype (starting with
     * {@code derived} and ending with {@code base}).
     *
     * &lt;p&gt;Each element in the returned path is a non-generic type, a raw type, or a parameterized type. The
     * {@link DeclaredType} at position {@code i} is always contained in the result of
     * {@link #directSupertypesOfTypeDeclaration(TypeElement)} applied to the type declaration of the type at position
     * {@code (i - 1)}.
     *
     * &lt;p&gt;This methods runs a Dijkstra shortest-path algorithm. It relies on {@link TypeElement#equals(Object)}
     * being well-defined (two object representing the same type declaration must compare equal). Consequently, if
     * {@link DeclaredType} instances have an identity, it must be guaranteed that there are no two instances
     * representing the same type declaration.
     *
     * @param base base type declaration
     * @param derived derived type
     * @return If there is an inheritance path from {@code derived} to {@code base}, then a {@code List&lt;DeclaredType&gt;}
     *     {@code p} such that {@code p.get(0).equals(toGenericType(derived))} and
     *     {@code toRawTypeDeclaration(p.get(p.size() - 1)).equals(base)} are {@code true}. Otherwise, {@code null} to
     *     indicate that there is no such path.
     */
    @Nullable
    private List&lt;DeclaredType&gt; getShortestPathToSuperType(TypeElement base, DeclaredType derived) {
<span class="fc" id="L811">        TypeElement typeElement = (TypeElement) derived.asElement();</span>

<span class="fc" id="L813">        Set&lt;TypeElement&gt; boundary = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L814">        Map&lt;TypeElement, TypeDeclarationVertexState&gt; dijkstraState = new HashMap&lt;&gt;();</span>

        // Distance from derived to itself is 0
<span class="fc" id="L817">        dijkstraState.put(typeElement, new TypeDeclarationVertexState(0, false, typeElement, derived));</span>
        // Start off with derived
<span class="fc" id="L819">        boundary.add(typeElement);</span>

        // Invariants:
        // - boundary only contains nodes that have *not* been visited
        // - For all visited nodes, the shortest path is known
<span class="fc bfc" id="L824" title="All 2 branches covered.">        while (!boundary.isEmpty()) {</span>
            // shortest := vertex in boundary with smallest distance from typeElement
<span class="fc" id="L826">            @Nullable TypeDeclarationVertexState shortest = null;</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">            for (TypeElement currentDeclaration: boundary) {</span>
<span class="fc" id="L828">                TypeDeclarationVertexState current = dijkstraState.get(currentDeclaration);</span>
<span class="pc bpc" id="L829" title="1 of 4 branches missed.">                if (shortest == null || current.distance &lt; shortest.distance) {</span>
<span class="fc" id="L830">                    shortest = current;</span>
                }
<span class="fc" id="L832">            }</span>
            // Since boundary is non-empty, shortest was assigned in the previous loop. Also note that due to the above
            // invariant, shortest has not been visited.
<span class="pc bpc" id="L835" title="3 of 6 branches missed.">            assert shortest != null &amp;&amp; !shortest.visited;</span>

            // Terminate if we found base. Since shortest.distance is non-decreasing over the loop iterations, it is
            // impossible to find a shorter path in future iterations.
<span class="fc bfc" id="L839" title="All 2 branches covered.">            if (shortest.typeElement.equals(base)) {</span>
<span class="fc" id="L840">                return shortest.toPath(derived);</span>
            }

            // Remove shortest from boundary.
<span class="fc" id="L844">            boundary.remove(shortest.typeElement);</span>
<span class="fc" id="L845">            shortest.visited = true;</span>

<span class="fc bfc" id="L847" title="All 2 branches covered.">            for (DeclaredType superType: directSupertypesOfTypeDeclaration(shortest.typeElement)) {</span>
                // A direct super type of a type declaration is either a non-generic type declaration or a raw type (in
                // both cases represented as DeclaredType with no actual type parameters) or a parameterized type
<span class="fc" id="L850">                TypeElement superDeclaration = (TypeElement) superType.asElement();</span>
<span class="fc" id="L851">                @Nullable TypeDeclarationVertexState stats = dijkstraState.get(superDeclaration);</span>

<span class="fc bfc" id="L853" title="All 2 branches covered.">                if (stats == null) {</span>
<span class="fc" id="L854">                    stats = new TypeDeclarationVertexState(Integer.MAX_VALUE, false, superDeclaration, superType);</span>
<span class="fc" id="L855">                    dijkstraState.put(superDeclaration, stats);</span>
                }

<span class="fc" id="L858">                int alt = shortest.distance + 1;</span>
<span class="fc bfc" id="L859" title="All 4 branches covered.">                if (!stats.visited &amp;&amp; alt &lt; stats.distance) {</span>
<span class="fc" id="L860">                    stats.distance = alt;</span>
<span class="fc" id="L861">                    stats.previous = shortest;</span>
<span class="fc" id="L862">                    boundary.add(superDeclaration);</span>
                }
<span class="fc" id="L864">            }</span>
<span class="fc" id="L865">        }</span>
<span class="fc" id="L866">        return null;</span>
    }

    /**
     * Visitor of a type mirror. Returns the erasure of the visited type mirror.
     *
     * @see #erasureVisitor
     */
<span class="fc" id="L874">    private final class ErasureVisitor extends ExtendedTypeKindVisitor7&lt;TypeMirror, Void&gt; {</span>
        @Override
        public TypeMirror visitDeclared(DeclaredType declaredType, @Nullable Void ignored) {
<span class="fc" id="L877">            TypeMirror originalEnclosingType = declaredType.getEnclosingType();</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">            @Nullable DeclaredType newEnclosingType = originalEnclosingType.getKind() == TypeKind.NONE</span>
                ? null
<span class="fc" id="L880">                : (DeclaredType) erasure(declaredType.getEnclosingType());</span>
<span class="fc" id="L881">            return getDeclaredType(newEnclosingType, (TypeElement) declaredType.asElement());</span>
        }

        /**
         * Returns the array type corresponding to the erasure of the component type.
         */
        @Override
        public TypeMirror visitArray(ArrayType arrayType, @Nullable Void ignored) {
<span class="fc" id="L889">            return getArrayType(erasure(arrayType.getComponentType()));</span>
        }

        /**
         * Returns the erasure of the leftmost bound of the given type variable.
         *
         * &lt;p&gt;The erasure of a type variable is the erasure of its leftmost bound (JLS §4.6). If multiple bounds are
         * present, the upper bound is modelled as an intersection type. The erasure of an intersection type is
         * guaranteed to have see right form (see {@link #visitIntersection(IntersectionType, Void)}).
         */
        @Override
        public TypeMirror visitTypeVariable(TypeVariable typeVariable, @Nullable Void ignored) {
<span class="fc" id="L901">            return erasure(typeVariable.getUpperBound());</span>
        }

        /**
         * Returns the erasure of the leftmost member of the given intersection type.
         *
         * &lt;p&gt;While JLS §4.6 does not mention intersection types (and thus, strictly speaking, the erasure of an
         * intersection type should be the unmodified intersection type itself), this implementation computes the
         * erasure of an intersection type as the erasure of its left-most type.
         */
        @Override
        public TypeMirror visitIntersection(IntersectionType intersectionType, @Nullable Void ignored) {
<span class="fc" id="L913">            return erasure(intersectionType.getBounds().get(0));</span>
        }

        /**
         * Returns the given type itself.
         *
         * &lt;p&gt;JLS §4.6 specifies: &quot;The erasure of every other type is the type itself.&quot;
         */
        @Override
        protected TypeMirror defaultAction(TypeMirror type, Void ignored) {
<span class="fc" id="L923">            return type;</span>
        }
    }

    /**
     * Returns the erasure of a type, as specified by JLS §4.6.
     *
     * @param type the type to be erased
     * @return the erasure of the given type
     * @throws IllegalArgumentException if given a package type
     */
    @Override
    public final TypeMirror erasure(TypeMirror type) {
<span class="fc" id="L936">        Objects.requireNonNull(type);</span>
<span class="fc" id="L937">        requireValidType(type);</span>

<span class="fc" id="L939">        return type.accept(erasureVisitor, null);</span>
    }

    /**
     * Returns the element corresponding to a type.
     *
     * &lt;p&gt;The type may be a {@code DeclaredType} or {@code TypeVariable}. Returns {@code null} if the type is not one
     * with a corresponding element.
     *
     * @param type the type
     * @return the element corresponding to the given type
     */
    @Override
    public final Element asElement(TypeMirror type) {
<span class="fc" id="L953">        Objects.requireNonNull(type);</span>
<span class="fc" id="L954">        requireValidType(type);</span>

<span class="fc bfc" id="L956" title="All 2 branches covered.">        if (type.getKind() == TypeKind.DECLARED) {</span>
<span class="fc" id="L957">            return ((DeclaredType) type).asElement();</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">        } else if (type.getKind() == TypeKind.TYPEVAR) {</span>
<span class="fc" id="L959">            return ((TypeVariable) type).asElement();</span>
        } else {
<span class="fc" id="L961">            return null;</span>
        }
    }

    /**
     * Returns whether the two given type arguments represent the same type.
     *
     * &lt;p&gt;If either of the arguments to this method represents a wildcard, this method will return false. As a
     * consequence, a wildcard is not the same type as itself.
     *
     * @param t1 the first type
     * @param t2 the second type
     * @return {@code true} if and only if the two types are the same
     */
    @Override
    public final boolean isSameType(TypeMirror t1, TypeMirror t2) {
<span class="fc" id="L977">        requireValidType(Objects.requireNonNull(t1));</span>
<span class="fc" id="L978">        requireValidType(Objects.requireNonNull(t2));</span>

<span class="fc bfc" id="L980" title="All 4 branches covered.">        return t1.getKind() != TypeKind.WILDCARD &amp;&amp; t1.equals(t2);</span>
    }

    /**
     * Returns the greatest lower bound (glb) of a wildcard extends bound and an upper bound of a type parameter.
     *
     * &lt;p&gt;This method is only called from {@link #capture(TypeMirror)}. JLS §5.1.10 defines the greatest lower bound
     * {@code glb(V_1, ..., V_m)} as {@code V_1 &amp; ... &amp; V_m}. Unfortunately, the specification provides no clarity
     * whether intersection types are allowed to be nested. This implementation takes the interpretation that
     * intersection types should not be nested. Therefore, the bounds contained in {@code originalUpperBound} are
     * unwrapped.
     *
     * @param wildcardExtendsBound extends bound of the wildcard type argument
     * @param originalUpperBound original upper bound of the type parameter
     * @return the greatest lower bound
     */
    private static TypeMirror[] greatestLowerBound(TypeMirror wildcardExtendsBound, TypeMirror originalUpperBound) {
<span class="fc" id="L997">        @Nullable TypeMirror[] result = null;</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">        if (originalUpperBound instanceof IntersectionType) {</span>
<span class="fc" id="L999">            IntersectionType originalIntersectionBound = (IntersectionType) originalUpperBound;</span>
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">            if (originalIntersectionBound.isIntersectionType()) {</span>
<span class="fc" id="L1001">                List&lt;? extends TypeMirror&gt; originalBounds = originalIntersectionBound.getBounds();</span>
<span class="fc" id="L1002">                result = new TypeMirror[1 + originalBounds.size()];</span>
<span class="fc" id="L1003">                int i = 0;</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">                for (TypeMirror originalBound: originalBounds) {</span>
<span class="fc" id="L1005">                    ++i;</span>
<span class="fc" id="L1006">                    result[i] = originalBound;</span>
<span class="fc" id="L1007">                }</span>
            }
        }

<span class="fc bfc" id="L1011" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc" id="L1012">            result = new TypeMirror[2];</span>
<span class="fc" id="L1013">            result[1] = originalUpperBound;</span>
        }

<span class="fc" id="L1016">        result[0] = wildcardExtendsBound;</span>
<span class="fc" id="L1017">        return result;</span>
    }

    /**
     * Returns the caputure conversion of (just) the given wildcard argument.
     *
     * &lt;p&gt;This method is only called by {@link #capture(TypeMirror)}.
     */
    private TypeVariable captureWildcardArgument(WildcardType wildcardArgument, TypeParameterElement typeParameter) {
<span class="fc" id="L1026">        TypeVariable originalTypeVariable = (TypeVariable) typeParameter.asType();</span>

        // Denoted U_i in JLS 5.1.10
<span class="fc" id="L1029">        TypeMirror originalUpperBound = originalTypeVariable.getUpperBound();</span>

        // Both of the following are denoted B_i in JLS 5.1.10 (in &quot;? extends B_i&quot; and &quot;? super B_i&quot;, respectively)
<span class="fc" id="L1032">        @Nullable TypeMirror wildcardExtendsBound = wildcardArgument.getExtendsBound();</span>
<span class="fc" id="L1033">        @Nullable TypeMirror wildcardSuperBound = wildcardArgument.getSuperBound();</span>

        TypeMirror newUpperBound;
        TypeMirror newLowerBound;

        // There exists a capture conversion from a parameterized type G&lt;T_1,...,T_n&gt; (§4.5) to a parameterized type
        // G&lt;S_1, ..., S_n&gt;, where, for 1 &lt;= i &lt;= n:
<span class="fc bfc" id="L1040" title="All 4 branches covered.">        if (wildcardExtendsBound == null &amp;&amp; wildcardSuperBound == null) {</span>
            // If T_i is a wildcard type argument (§4.5.1) of the form ?, then S_i is a fresh type variable whose
            // upper bound is U_i[A_1 := S_1, ..., A_n := S_n] and whose lower bound is the null type (§4.1).
<span class="fc" id="L1043">            newUpperBound = originalUpperBound;</span>
<span class="fc" id="L1044">            newLowerBound = getNullType();</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">        } else if (wildcardSuperBound == null) {</span>
            // If T_i is a wildcard type argument of the form ? extends B_i, then S_i is a fresh type variable whose
            // upper bound is glb(B_i, U_i[A_1 := S_1, ..., A_n := S_n]) and whose lower bound is the null type.
            //
            // glb(V_1, ..., V_m) is defined as V_1 &amp; ... &amp; V_m.
            // It is a compile-time error if, for any two classes (not interfaces) V_i and V_j, V_i is not a
            // subclass of V_j or vice versa.
<span class="fc" id="L1052">            newUpperBound = getIntersectionType(greatestLowerBound(wildcardExtendsBound, originalUpperBound));</span>
<span class="fc" id="L1053">            newLowerBound = getNullType();</span>
        } else {
            // If T_i is a wildcard type argument of the form ? super B_i, then S_i is a fresh type variable whose
            // upper bound is U_i[A_1 := S1, ..., A_n := S_n] and whose lower bound is B_i.
<span class="pc bpc" id="L1057" title="2 of 4 branches missed.">            assert wildcardExtendsBound == null;</span>

<span class="fc" id="L1059">            newUpperBound = originalUpperBound;</span>
<span class="fc" id="L1060">            newLowerBound = wildcardSuperBound;</span>
        }

<span class="fc" id="L1063">        return getTypeVariable(typeParameter, newUpperBound, newLowerBound, wildcardArgument);</span>
    }

    /**
     * Returns the capture conversion of the given type, as specified by JLS §5.1.10.
     *
     * @param type the type to be converted
     * @return the result of applying capture conversion
     * @throws IllegalArgumentException if given an executable or package type
     */
    @Override
    public final TypeMirror capture(TypeMirror type) {
<span class="fc" id="L1075">        Objects.requireNonNull(type);</span>
<span class="fc" id="L1076">        requireValidType(type);</span>

        // JLS §5.1.10 states: &quot;Capture conversion on any type other than a parameterized type (§4.5) acts as an
        // identity conversion (§5.1.1).&quot;
<span class="fc bfc" id="L1080" title="All 2 branches covered.">        if (type.getKind() != TypeKind.DECLARED) {</span>
<span class="fc" id="L1081">            return type;</span>
        }

<span class="fc" id="L1084">        DeclaredType declaredType = (DeclaredType) type;</span>
<span class="fc" id="L1085">        List&lt;? extends TypeMirror&gt; typeArguments = declaredType.getTypeArguments();</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if (typeArguments.isEmpty()) {</span>
<span class="fc" id="L1087">            return declaredType;</span>
        }

<span class="fc" id="L1090">        TypeElement typeDeclaration = (TypeElement) declaredType.asElement();</span>
<span class="fc" id="L1091">        Iterator&lt;? extends TypeMirror&gt; typeArgumentIterator = typeArguments.iterator();</span>
<span class="fc" id="L1092">        Iterator&lt;? extends TypeParameterElement&gt; typeParameterIterator = typeDeclaration.getTypeParameters().iterator();</span>
<span class="fc" id="L1093">        TypeMirror[] newArguments = new TypeMirror[typeArguments.size()];</span>
<span class="fc" id="L1094">        Map&lt;TypeParameterElement, TypeMirror&gt; substitutions = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">        for (int index = 0; index &lt; newArguments.length; ++index) {</span>
<span class="fc" id="L1096">            TypeMirror typeArgument = typeArgumentIterator.next();</span>
<span class="fc" id="L1097">            TypeParameterElement typeParameter = typeParameterIterator.next();</span>
            TypeMirror substitution;

<span class="fc bfc" id="L1100" title="All 2 branches covered.">            if (typeArgument.getKind() != TypeKind.WILDCARD) {</span>
<span class="fc" id="L1101">                newArguments[index] = typeArgument;</span>
<span class="fc" id="L1102">                substitution = typeArgument;</span>
            } else {
                // For the intermediate declared type (see below), we need the original type variable corresponding to
                // the formal type parameter. Only original type variables will be replaced by the substitutionVisitor.
<span class="fc" id="L1106">                newArguments[index] = typeParameter.asType();</span>
<span class="fc" id="L1107">                substitution = captureWildcardArgument((WildcardType) typeArgument, typeParameter);</span>
            }
<span class="fc" id="L1109">            substitutions.put(typeParameter, substitution);</span>
        }

<span class="fc" id="L1112">        TypeMirror enclosingType = declaredType.getEnclosingType();</span>

        // Construct intermediateDeclaredType that already has type variables in its argument list instead of wildcard
        // arguments.
        DeclaredType intermediateDeclaredType;
<span class="fc bfc" id="L1117" title="All 2 branches covered.">        if (enclosingType.getKind() == TypeKind.DECLARED) {</span>
<span class="fc" id="L1118">            intermediateDeclaredType = getDeclaredType((DeclaredType) enclosingType, typeDeclaration, newArguments);</span>
        } else {
<span class="fc" id="L1120">            intermediateDeclaredType = getDeclaredType(typeDeclaration, newArguments);</span>
        }

<span class="fc" id="L1123">        return substitute(intermediateDeclaredType, substitutions);</span>
    }

    /**
     * Returns a new type variable that corresponds to the given formal type parameter and that has the given actual
     * upper and lower bounds.
     *
     * &lt;p&gt;This method is primarily needed during capture conversion, in order to create a fresh type variable that
     * overrides the bounds of the formal type parameter it represents. This method is also called during substitution.
     * As an example, given a formal type parameter {@code T extends Object} and an upper bound {@code Number}, this
     * method returns the type variable {@code T} with upper bound {@code Number}.
     *
     * &lt;p&gt;This method is not suited for creating type variables with recursive type bounds if these bounds override the
     * bounds of the formal type parameter (as only happens during capture conversion). In order to create such a type
     * variable, this method may be used to create an interim type variable, where the (overridden) upper and lower
     * bounds should only reference the type variable returned by {@link TypeParameterElement#asType()}. As a second
     * step, {@link #substitute(TypeMirror, Map)} may then be used to substitute the original type variable with the
     * interim type variable. The result will be a fresh type variable with the overridden bounds, and these bounds
     * will reference the fresh type variable instead of the original type variable.
     *
     * @param typeParameter the formal type parameter
     * @param upperBound the upper bound for the new type variable, may contain recursive references to
     *     {@code typeParameter.asType()}
     * @param lowerBound the lower bound for the new type variable, may contain recursive references to
     *     {@code typeParameter.asType()}
     * @param capturedTypeArgument the wildcard type argument that new type variable captures as part of a capture
     *     conversion (§5.1.10 JLS), or {@code null} if the new type variable is not the result of a capture conversion
     * @return the new type variable
     * @throws NullPointerException if any of the first three arguments is null
     */
    protected TypeVariable getTypeVariable(TypeParameterElement typeParameter, TypeMirror upperBound,
            TypeMirror lowerBound, @Nullable WildcardType capturedTypeArgument) {
<span class="fc" id="L1155">        Objects.requireNonNull(typeParameter);</span>
<span class="fc" id="L1156">        Objects.requireNonNull(upperBound);</span>
<span class="fc" id="L1157">        Objects.requireNonNull(lowerBound);</span>
<span class="fc" id="L1158">        requireValidType(upperBound);</span>
<span class="fc" id="L1159">        requireValidType(lowerBound);</span>
<span class="fc" id="L1160">        requireValidType(capturedTypeArgument);</span>

<span class="fc" id="L1162">        TypeVariable typeVariable = createTypeVariable(typeParameter, capturedTypeArgument);</span>
<span class="fc" id="L1163">        setTypeVariableBounds(typeVariable, upperBound, lowerBound);</span>
<span class="fc" id="L1164">        return typeVariable;</span>
    }

    /**
     * Creates a new &lt;em&gt;unfinished&lt;/em&gt; type variable for the given formal parameter.
     *
     * &lt;p&gt;Whenever this method is called within this class, the returned type variable is guaranteed to be passed to
     * {@link #setTypeVariableBounds(TypeVariable, TypeMirror, TypeMirror)} before being used as a {@link TypeVariable}
     * instance. That is, the returned type variable is considered to be under construction until being passed to
     * {@link #setTypeVariableBounds(TypeVariable, TypeMirror, TypeMirror)}, and only after that method call, the type
     * variable will have to satisfy the contract specified by interface {@link TypeVariable} and its super-interfaces.
     *
     * &lt;p&gt;Before {@link #setTypeVariableBounds(TypeVariable, TypeMirror, TypeMirror)} is called on the returned
     * {@link TypeVariable}, calling either {@link TypeVariable#getUpperBound()} or {@link TypeVariable#getLowerBound()}
     * must trigger an {@link IllegalStateException}.
     *
     * &lt;p&gt;Note that the previous paragraph does not guarantee that
     * {@link #setTypeVariableBounds(TypeVariable, TypeMirror, TypeMirror)} is always called on the newly returned
     * type-variable instance. If any exception occurs before the new type-variable could be used, then
     * {@link #setTypeVariableBounds(TypeVariable, TypeMirror, TypeMirror)} may not be called (even if the exception is
     * unrelated to the construction of the new type-variable instance).
     *
     * &lt;p&gt;The {@link TypeVariable} interface does not provide access to captured wildcard type arguments. It can be
     * retrieved by calling {@link #capturedTypeArgument(TypeVariable)} instead.
     *
     * @param typeParameter the formal type parameter
     * @param capturedTypeArgument the wildcard type argument that new type variable captures as part of a capture
     *     conversion (§5.1.10 JLS), or {@code null} if the new type variable is not the result of a capture conversion
     * @return new unfinished type variable for the given formal parameter, which may not yet satisfy the contracts
     *     of {@link TypeVariable}
     * @see #setTypeVariableBounds(TypeVariable, TypeMirror, TypeMirror)
     * @see #capturedTypeArgument(TypeVariable)
     * @throws NullPointerException if {@code typeParameter} is null
     */
    protected abstract TypeVariable createTypeVariable(TypeParameterElement typeParameter,
        @Nullable WildcardType capturedTypeArgument);

    /**
     * Sets the bounds of a type variable previously returned by
     * {@link #createTypeVariable(TypeParameterElement, WildcardType)}.
     *
     * &lt;p&gt;Before an (unfinished) type-variable instance returned by
     * {@link #createTypeVariable(TypeParameterElement, WildcardType)} is used by this class, this method is guaranteed
     * to be called exactly once.
     *
     * &lt;p&gt;Implementations that create effectively immutable {@link TypeMirror} instances may use this method to &quot;freeze&quot;
     * the given type-variable instance.
     *
     * @param typeVariable type variable previously returned by
     *     {@link #createTypeVariable(TypeParameterElement, WildcardType)}
     * @param upperBound Upper bound for the given type variable. If no explicit upper bound is used, a
     *     {@link DeclaredType} representing {@link Object} will be passed.
     * @param lowerBound Lower bound for the given type variable. This may a {@link NullType} instance, unless capture
     *     conversion produced a type variable with a non-trivial lower bound.
     * @see #createTypeVariable(TypeParameterElement, WildcardType)
     */
    protected abstract void setTypeVariableBounds(TypeVariable typeVariable, TypeMirror upperBound,
        TypeMirror lowerBound);

    /**
     * Returns the captured wildcard type argument of the given type variable, or null if the given type variable is not
     * the result of a capture conversion.
     *
     * &lt;p&gt;This method returns the wildcard type argument that was previously passed to
     * {@link #createTypeVariable(TypeParameterElement, WildcardType)}.
     *
     * @param typeVariable the type variable that may be the result of a capture conversion
     * @return the captured wildcard type argument, or null if not applicable
     */
    @Nullable
    protected abstract WildcardType capturedTypeArgument(TypeVariable typeVariable);

    /**
     * Returns a new intersection type. At least one bounds needs to be given.
     *
     * @param bounds the bounds of the new intersection type
     * @return the new intersection type
     * @throws IllegalArgumentException if the given array is empty
     */
    public abstract IntersectionType getIntersectionType(TypeMirror... bounds);

    /**
     * Visitor of {@link TypeMirror} instances that appends the {@link String} representation to the
     * {@link StringBuilder} instance passed as visitor argument.
     *
     * &lt;p&gt;This visitor is only used within this class and only on &lt;em&gt;valid&lt;/em&gt; {@link TypeMirror} instances. Hence, it
     * can be asserted that the visitor parameter is always non-null.
     *
     * @see #requireValidType(TypeMirror)
     */
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">    private final class ToStringVisitor extends ExtendedTypeKindVisitor7&lt;Void, StringBuilder&gt; {</span>
        @Override
        public Void visitPrimitive(PrimitiveType primitiveType, @Nullable StringBuilder stringBuilder) {
<span class="pc bpc" id="L1257" title="2 of 4 branches missed.">            assert stringBuilder != null;</span>
<span class="fc" id="L1258">            stringBuilder.append(primitiveType.getKind().toString().toLowerCase());</span>
<span class="fc" id="L1259">            return null;</span>
        }

        @Override
        public Void visitNull(NullType nullType, @Nullable StringBuilder stringBuilder) {
<span class="pc bpc" id="L1264" title="2 of 4 branches missed.">            assert stringBuilder != null;</span>
<span class="fc" id="L1265">            stringBuilder.append(&quot;null&quot;);</span>
<span class="fc" id="L1266">            return null;</span>
        }

        @Override
        public Void visitNoType(NoType noType, @Nullable StringBuilder stringBuilder) {
<span class="pc bpc" id="L1271" title="2 of 4 branches missed.">            assert stringBuilder != null;</span>
<span class="fc" id="L1272">            stringBuilder.append(noType.getKind().toString().toLowerCase());</span>
<span class="fc" id="L1273">            return null;</span>
        }

        @Override
        public Void visitDeclared(DeclaredType declaredType, @Nullable StringBuilder stringBuilder) {
<span class="pc bpc" id="L1278" title="2 of 4 branches missed.">            assert stringBuilder != null;</span>
<span class="fc" id="L1279">            TypeMirror enclosingType = declaredType.getEnclosingType();</span>
<span class="fc" id="L1280">            TypeElement typeElement = (TypeElement) declaredType.asElement();</span>
<span class="fc bfc" id="L1281" title="All 2 branches covered.">            if (enclosingType.getKind() == TypeKind.DECLARED) {</span>
<span class="fc" id="L1282">                visitDeclared((DeclaredType) enclosingType, stringBuilder);</span>
<span class="fc" id="L1283">                stringBuilder.append('.').append(typeElement.getSimpleName());</span>
            } else {
<span class="fc" id="L1285">                stringBuilder.append(typeElement.getQualifiedName());</span>
            }

<span class="fc" id="L1288">            List&lt;? extends TypeMirror&gt; typeArguments = declaredType.getTypeArguments();</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">            if (!typeArguments.isEmpty()) {</span>
<span class="fc" id="L1290">                stringBuilder.append('&lt;');</span>
<span class="fc" id="L1291">                appendList(stringBuilder, typeArguments, &quot;, &quot;);</span>
<span class="fc" id="L1292">                stringBuilder.append('&gt;');</span>
            }
<span class="fc" id="L1294">            return null;</span>
        }

        @Override
        public Void visitArray(ArrayType arrayType, @Nullable StringBuilder stringBuilder) {
<span class="pc bpc" id="L1299" title="2 of 4 branches missed.">            assert stringBuilder != null;</span>
<span class="fc" id="L1300">            arrayType.getComponentType().accept(this, stringBuilder);</span>
<span class="fc" id="L1301">            stringBuilder.append(&quot;[]&quot;);</span>
<span class="fc" id="L1302">            return null;</span>
        }

        @Override
        public Void visitTypeVariable(TypeVariable typeVariable, @Nullable StringBuilder stringBuilder) {
<span class="pc bpc" id="L1307" title="2 of 4 branches missed.">            assert stringBuilder != null;</span>
<span class="fc" id="L1308">            @Nullable WildcardType capturedTypeArgument = capturedTypeArgument(typeVariable);</span>
<span class="fc bfc" id="L1309" title="All 2 branches covered.">            if (capturedTypeArgument != null) {</span>
<span class="fc" id="L1310">                stringBuilder.append(&quot;capture&lt;&quot;);</span>
<span class="fc" id="L1311">                capturedTypeArgument.accept(this, stringBuilder);</span>
<span class="fc" id="L1312">                stringBuilder.append('&gt;');</span>
            } else {
<span class="fc" id="L1314">                stringBuilder.append(typeVariable.asElement().getSimpleName());</span>
            }
<span class="fc" id="L1316">            return null;</span>
        }

        @Override
        public Void visitWildcard(WildcardType wildcardTypeArgument, @Nullable StringBuilder stringBuilder) {
<span class="pc bpc" id="L1321" title="2 of 4 branches missed.">            assert stringBuilder != null;</span>
<span class="fc" id="L1322">            stringBuilder.append('?');</span>
<span class="fc" id="L1323">            @Nullable TypeMirror extendsBound = wildcardTypeArgument.getExtendsBound();</span>
<span class="fc bfc" id="L1324" title="All 2 branches covered.">            if (extendsBound != null) {</span>
<span class="fc" id="L1325">                stringBuilder.append(&quot; extends &quot;);</span>
<span class="fc" id="L1326">                extendsBound.accept(this, stringBuilder);</span>
            }
<span class="fc" id="L1328">            @Nullable TypeMirror superBound = wildcardTypeArgument.getSuperBound();</span>
<span class="fc bfc" id="L1329" title="All 2 branches covered.">            if (superBound != null) {</span>
<span class="fc" id="L1330">                stringBuilder.append(&quot; super &quot;);</span>
<span class="fc" id="L1331">                superBound.accept(this, stringBuilder);</span>
            }
<span class="fc" id="L1333">            return null;</span>
        }

        @Override
        public Void visitIntersection(IntersectionType intersectionType, @Nullable StringBuilder stringBuilder) {
<span class="pc bpc" id="L1338" title="2 of 4 branches missed.">            assert stringBuilder != null;</span>
<span class="fc" id="L1339">            appendList(stringBuilder, intersectionType.getBounds(), &quot; &amp; &quot;);</span>
<span class="fc" id="L1340">            return null;</span>
        }

        private void appendList(StringBuilder stringBuilder, List&lt;? extends TypeMirror&gt; types, String glue) {
<span class="pc bpc" id="L1344" title="2 of 4 branches missed.">            assert !types.isEmpty();</span>

<span class="fc" id="L1346">            boolean first = true;</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">            for (TypeMirror type: types) {</span>
<span class="fc bfc" id="L1348" title="All 2 branches covered.">                if (first) {</span>
<span class="fc" id="L1349">                    first = false;</span>
                } else {
<span class="fc" id="L1351">                    stringBuilder.append(glue);</span>
                }
<span class="fc" id="L1353">                type.accept(this, stringBuilder);</span>
<span class="fc" id="L1354">            }</span>
<span class="fc" id="L1355">        }</span>
    }

    /**
     * Returns the canonical string representation of the given type.
     *
     * @param type type
     * @return canonical string representation of the given type
     */
    public final String toString(TypeMirror type) {
<span class="fc" id="L1365">        requireValidType(Objects.requireNonNull(type));</span>

<span class="fc" id="L1367">        StringBuilder stringBuilder = new StringBuilder(DEFAULT_STRING_BUILDER_SIZE);</span>
<span class="fc" id="L1368">        type.accept(toStringVisitor, stringBuilder);</span>
<span class="fc" id="L1369">        return stringBuilder.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>